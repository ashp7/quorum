package main

import (
	"bytes"
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common/compiler"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"math/big"
	"os/exec"
	"reflect"
	"strconv"
	"strings"
   "path/filepath"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	log "github.com/sirupsen/logrus"
)

const (
	nodeURL    = "http://localhost:22000" // Replace with your Quorum node URL
	gasLimit = 700000
	gasPrice = 0
)

var (
 privateKey	string  = "0x692a322c4eaacafc4ea25c8513270c9d62009f88a7c2866d51b820d5e4bd9696"
)

func main() {


	solidityFile := "../../contracts/NFTCollateral.sol"
    contract, err := CompileContract(solidityFile, "istanbul", "NFTCollateral.sol:NFTCollateralLoan")
    fmt.Printf(" err is %v \n",  err)

	abiBytes, err := json.Marshal(contract.Info.AbiDefinition)
	if err != nil {
		log.Fatalf("Failed to marshal ABI: %v", err)
	}

	parsedABI, err := abi.JSON(bytes.NewReader(abiBytes))
	if err != nil {
		log.Fatalf("Failed to parse ABI: %v", err)
	}

	// Decode the private key from hex string
	privateKeyBytes, err := hex.DecodeString(privateKey[2:]) // Assuming privateKey is a hex string with "0x" prefix
	if err != nil {
		log.Fatal("Failed to decode hex string of private key: ", err)
	}

	// Parse the ECDSA private key
	privKey, err := crypto.ToECDSA(privateKeyBytes)
	if err != nil {
		log.Fatal("Failed to parse ECDSA private key: ", err)
	}

	auth, err := bind.NewKeyedTransactorWithChainID(privKey, big.NewInt(1337))
	if err != nil {
		log.Fatal(err)
	}
	// Set the gas price and gas limit
	auth.GasPrice = big.NewInt(gasPrice)
	auth.GasLimit = gasLimit

	client, err := ethclient.Dial(nodeURL)
	if err != nil {
		log.Fatal(err)
	}

	address, tx, _, err := bind.DeployContract(auth, parsedABI, common.FromHex(contract.Code), client)
	if err != nil {
		log.Fatalf("Failed to deploy contract: %v", err)
	}
	fmt.Printf("Contract deployed at address: %s\n", address.Hex())

	// Wait for the transaction to be mined

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	receipt, err := bind.WaitMined(ctx, client, tx)
	if err != nil {
		if err == context.DeadlineExceeded {
			log.Println("Transaction mining exceeded 30 seconds, attempting to replace transaction")

			// Replace the transaction
			nonce := tx.Nonce()
			var price int64 = 10000
			newGasPrice := new(big.Int).Mul(big.NewInt(price), big.NewInt(2)) // Increase the gas price

			// Create a new transaction with the same nonce and higher gas price
			newTx := types.NewTransaction(nonce, auth.From, big.NewInt(0), tx.Gas(), newGasPrice, nil)

			signer := types.NewEIP155Signer(big.NewInt(1337))
			// Sign the new transaction
			signedTx, err := types.SignTx(newTx, signer, privKey)
			if err != nil {
				log.Fatalf("Failed to sign new transaction: %v", err)
			}

			opts := bind.PrivateTxArgs{}
			err = client.SendTransaction(context.Background(), signedTx, opts)
			if err != nil {
				log.Fatalf("Failed to send new transaction: %v", err)
			}

			log.Printf("New transaction sent to replace original: %s\n", signedTx.Hash().Hex())
		} else {
			log.Fatalf("Failed to wait for transaction mining: %v", err)
		}
	}

	fmt.Printf("Transaction hash: %s\n", receipt.TxHash.Hex())


	// Pack the arguments for calling the contract
	abiJSON, err := json.Marshal(contract.Info.AbiDefinition)
	if err != nil {
		log.Errorf("serializing ABI: %s", err)
		return
	}
	abi, err := abi.JSON(bytes.NewReader(abiJSON))
	if err != nil {
		log.Errorf("parsing ABI: %s", err)
		return
	}

	methodName := "setValue"              // Replace with your method name
	strArgs := []string{"100"}            // Replace with your string arguments
	typedArgs, err := GenerateTypedArgs(abi, methodName, strArgs)
	if err != nil {
		log.Fatalf("Failed to generate typed arguments: %v", err)
	}



	nonce := uint64(0)                             // Replace with the nonce of the account
	to := common.HexToAddress("contract_address")  // Replace with your contract address
	amount := big.NewInt(0)                        // Amount of Ether to send, set to 0 if not sending Ether
	gasLimit := uint64(21000)                      // Replace with an appropriate gas limit
	gasPrice := big.NewInt(30000000000)            // Replace with an appropriate gas price in wei

	// Create the transaction
	tx, err = CallContractMethod(abi, methodName, typedArgs, nonce, to, amount, gasLimit, gasPrice)
	if err != nil {
		fmt.Printf("Failed to create contract call transaction: %v\n", err)
		return
	}

	fmt.Printf("Created transaction: %s\n", tx.Hash().Hex())


}

func compileContract(basePath, contractFile , contractName string) (string, string, error) {
	contractFilePath := filepath.Join(basePath, "contracts", contractFile)
	args := []string {
		"--abi", "--bin", "--base-path", basePath+"/contracts", "--include-path" , basePath + "/node_modules", contractFilePath,
	}

	cmd := exec.Command("/usr/local/bin/solc", args... )
	fmt.Printf("Passed in args are %v\n", args)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", "", fmt.Errorf("failed to compile contract: %s", err)
	}

	// Extract the contract ABI and bytecode from the solc output
	outputStr := string(output)

	section := extractSection(outputStr, contractFile + ":" + contractName)
	contractBin := extractContractBin(section)
	contractABI := extractContractABI(section)

	fmt.Printf("Section is %s  \nContract ABI is %s \n contract bin is %s \n\n", section, contractABI, contractBin)


	return contractABI, contractBin, nil
}
func extractSection(output, contractIdentifier string) string {
	startIdentifier := fmt.Sprintf("======= %s =======", contractIdentifier)
	endIdentifier := "======="

	startIdx := strings.Index(output, startIdentifier)
	if startIdx == -1 {
		return ""
	}
	startIdx += len(startIdentifier)

	endIdx := strings.Index(output[startIdx:], endIdentifier)
	if endIdx == -1 {
		endIdx = len(output)
	} else {
		endIdx += startIdx
	}

	return output[startIdx:endIdx]
}

func extractContractABI(output string) string {
	abiIdentifier := "Contract JSON ABI"
	startIdx := strings.Index(output, abiIdentifier)
	if startIdx == -1 {
		return ""
	}
	startIdx += len(abiIdentifier)

	endIdx := strings.Index(output[startIdx:], "\n\n")
	if endIdx == -1 {
		return strings.TrimSpace(output[startIdx:])
	}

	return strings.TrimSpace(output[startIdx : startIdx+endIdx])
}

func extractContractBin(output string) string {
	binIdentifier := "Binary:"
	abiIdentifier := "Contract JSON ABI"

	binStartIdx := strings.Index(output, binIdentifier)
	if binStartIdx == -1 {
		return ""
	}
	binStartIdx += len(binIdentifier)

	binEndIdx := strings.Index(output[binStartIdx:], "\n\n")
	if binEndIdx == -1 {
		binEndIdx = len(output) - binStartIdx
	}

	// Check if ABI section follows binary and adjust the end index
	abiStartIdx := strings.Index(output[binStartIdx:], abiIdentifier)
	if abiStartIdx != -1 && abiStartIdx < binEndIdx {
		binEndIdx = abiStartIdx
	}

	return strings.TrimSpace(output[binStartIdx : binStartIdx+binEndIdx])
}

type SolcVersion struct {
	Path    string
	Version string
}





const (
solcVer = "0.8.23"
solcPath = "/usr/local/bin/solc"
)

// CompileContract uses solc to compile the Solidity source and
func CompileContract(solidityFile, evmVersion, contractName string) (*compiler.Contract, error) {
	//var c CompiledSolidity

	solcArgs := []string{
		"--combined-json", "bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata",
		"--optimize",
		"--evm-version", evmVersion,
		"--allow-paths", ".",
		"--include-path", "../../node_modules",
		"--base-path", "../../contracts",
		solidityFile,
	}
	solOptionsString := strings.Join(append([]string{solcPath}, solcArgs...), " ")
	log.Debugf("Compiling: %s", solOptionsString)
	cmd := exec.Command(solcPath, solcArgs...)

	// Compile the solidity
	var stderr, stdout bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Stdout = &stdout
	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to compile [%s]: %s", err, stderr.String())
	}

	compiled, err := compiler.ParseCombinedJSON(stdout.Bytes(), "", solcVer, solcVer, solOptionsString)
	if err != nil {
		return nil, fmt.Errorf("failed to parse solc output: %s", err)
	}

	// Check we only have one conract and grab the code/info
	var contract *compiler.Contract
	contractNames := reflect.ValueOf(compiled).MapKeys()
	if contractName != "" {
		if _, ok := compiled[contractName]; !ok {
			return nil, fmt.Errorf("contract %s not found in Solidity file: %s", contractName, contractNames)
		}
		contract = compiled[contractName]
	} else if len(contractNames) != 1 {
		return nil, fmt.Errorf("more than one contract in Solidity file, please set one to call: %s", contractNames)
	} else {
		contractName = contractNames[0].String()
		contract = compiled[contractName]
	}

	return contract, nil
	/*
	c.ContractInfo = contract.Info
	c.Compiled = contract.Code

	// Pack the arguments for calling the contract
	abiJSON, err := json.Marshal(contract.Info.AbiDefinition)
	if err != nil {
		return nil, fmt.Errorf("serializing ABI: %s", err)
	}
	abi, err := abi.JSON(bytes.NewReader(abiJSON))
	if err != nil {
		return nil, fmt.Errorf("parsing ABI: %s", err)
	}
	fmt.Printf("abi is %v", abi)
	typedArgs, err := GenerateTypedArgs(abi, method, args)
	if err != nil {
		return nil, err
	}
	packedCall, err := abi.Pack(method, typedArgs...)
	if err != nil {
		return nil, fmt.Errorf("packing arguments %s for call %s: %s", args, method, err)
	}
	c.PackedCall = packedCall
	return &c, nil

	 */
}

// CallContractMethod creates a transaction for calling a method on a smart contract
func CallContractMethod(contractAbi abi.ABI, methodName string, args []interface{}, nonce uint64, to common.Address, amount *big.Int, gasLimit uint64, gasPrice *big.Int) (*types.Transaction, error) {
	// Pack the arguments for the contract call
	packedArgs, err := contractAbi.Pack(methodName, args...)
	if err != nil {
		return nil, fmt.Errorf("error packing arguments for method %s: %v", methodName, err)
	}

	// Create the transaction
	tx := types.NewTransaction(nonce, to, amount, gasLimit, gasPrice, packedArgs)
	return tx, nil
}


// GenerateTypedArgs converts string arguments into their corresponding types based on the ABI and method name
func GenerateTypedArgs(contractAbi abi.ABI, methodName string, strArgs []string) ([]interface{}, error) {
	method, exists := contractAbi.Methods[methodName]
	if !exists {
		return nil, fmt.Errorf("method '%s' not found in ABI", methodName)
	}

	if len(method.Inputs) != len(strArgs) {
		return nil, fmt.Errorf("method '%s' requires %d args but got %d", methodName, len(method.Inputs), len(strArgs))
	}

	var typedArgs []interface{}
	for i, input := range method.Inputs {
		arg := strArgs[i]
		switch input.Type.T {
		case abi.StringTy: // string
			typedArgs = append(typedArgs, arg)

		case abi.IntTy, abi.UintTy: // int, uint
			argInt, ok := new(big.Int).SetString(arg, 10)
			if !ok {
				return nil, fmt.Errorf("failed to convert argument %d (%s) to big.Int for type %s", i, arg, input.Type)
			}
			typedArgs = append(typedArgs, argInt)

		case abi.BoolTy: // bool
			argBool, err := strconv.ParseBool(arg)
			if err != nil {
				return nil, fmt.Errorf("failed to convert argument %d (%s) to bool: %v", i, arg, err)
			}
			typedArgs = append(typedArgs, argBool)

		case abi.AddressTy: // address
			if !common.IsHexAddress(arg) {
				return nil, fmt.Errorf("argument %d (%s) is not a valid hex address", i, arg)
			}
			typedArgs = append(typedArgs, common.HexToAddress(arg))

		default:
			// Add support for additional types as needed
			return nil, fmt.Errorf("unsupported argument type %s for argument %d", input.Type, i)
		}
	}

	return typedArgs, nil
}



// GenerateTypedArgs parses string arguments into a range of types to pass to the ABI call
func GenerateTypedArgsOld(abi abi.ABI, methodName string, strargs []string) ([]interface{}, error) {

	method, exist := abi.Methods[methodName]
	if !exist {
		return nil, fmt.Errorf("method '%s' not found", methodName)
	}

	log.Debug("Parsing args for method: ", method)
	var typedArgs []interface{}
	for idx, inputArg := range method.Inputs {
		if idx >= len(strargs) {
			return nil, fmt.Errorf("method requires %d args: %s", len(method.Inputs), method)
		}
		strval := strargs[idx]
		switch inputArg.Type.String() {
		case "string":
			typedArgs = append(typedArgs, strval)
		case "int256", "uint256":
			bigInt := big.NewInt(0)
			if _, ok := bigInt.SetString(strval, 10); !ok {
				return nil, fmt.Errorf("could not convert '%s' to %s", strval, inputArg.Type)
			}
			typedArgs = append(typedArgs, bigInt)
		case "bool":
			typedArgs = append(typedArgs, strings.ToLower(strval) == "true")
		case "address":
			if !common.IsHexAddress(strval) {
				return nil, fmt.Errorf("invalid hex address for arg %d: %s", idx, strval)
			}
			typedArgs = append(typedArgs, common.HexToAddress(strval))
		default:
			return nil, fmt.Errorf("no string parsing configured yet for type %s", inputArg.Type)
		}
	}

	return typedArgs, nil

}
